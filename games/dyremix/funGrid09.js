// JavaScript Documentvar FUNGRID = {};FUNGRID.log = function (message) {    try {        console.log(message);    } catch (exception) {        return;    }}// Returns Rectangle objectFUNGRID.Rectangle = function (x, y, width, height) {    x = x || 0;    y = y || 0;    width = width || 0;    height = height || 0;    var r = {x: x, y: y, width: width, height: height};    // Returns true if the Rectangle object contains Point p    r.containsPoint = function (p) {        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;    }    // Returns true if the Rectangle object intersects Rectangle rect    r.intersects = function (rect) {        return rect.x < this.x + this.width && rect.x + rect.width > this.x && rect.y < this.y + this.height && rect.y + rect.height > this.y;    }    return r;}// Returns Point objectFUNGRID.Point = function (x, y) {    x = x || 0;    y = y || 0;    p = {x: x, y: y};    p.toString = function () {        return "{x:" + x + ", y:" + y + "}";    }    return p;}FUNGRID.log('FunGrid.js v0.9');FUNGRID.maxFps = 30; // FUNGRID.timeInterval = 1000 / FUNGRID.maxFps; // in msFUNGRID.canvas = null; // canvas DOM objectFUNGRID.context = null; // canvas contextFUNGRID.lastUpdate = new Date().getTime();FUNGRID.fps = 0;FUNGRID.currentTime = 0;FUNGRID.deltaTime = 0;FUNGRID.drawFPS = false;FUNGRID.gameObjects = [];FUNGRID.polyLineGameObjects = [];FUNGRID.zoneGameObjects = [];FUNGRID.canX = 0;FUNGRID.canY = 0;FUNGRID.isDown = 0;FUNGRID.w = 0;FUNGRID.h = 0;// ViewportFUNGRID.viewport = FUNGRID.Rectangle();FUNGRID.futureViewport = FUNGRID.Point();FUNGRID.minVpX = null;FUNGRID.maxVpX = null;FUNGRID.minVpY = null;FUNGRID.maxVpY = null;FUNGRID.maxScrollSpeed = 2000;FUNGRID.viewportDelay = 1.5;FUNGRID.doClearCanvas = true;FUNGRID.init = function (canvasId) {    canvasId = canvasId || "canvas";    FUNGRID.canvas = document.getElementById(canvasId);    FUNGRID.w = FUNGRID.canvas.width;    FUNGRID.h = FUNGRID.canvas.height;    FUNGRID.viewport = FUNGRID.Rectangle(0, 0, FUNGRID.w, FUNGRID.h);    FUNGRID.context = FUNGRID.canvas.getContext("2d");    FUNGRID.gameObjects = [];    if (!FUNGRID.canvas || !FUNGRID.context) {        FUNGRID.log("FunGrid init failed!");    }    FUNGRID.log("FunGrid initialized!");}FUNGRID.update = function () {    FUNGRID.updateViewport();    FUNGRID.updateGameObjects();    if (FUNGRID.doClearCanvas) {    	FUNGRID.clearCanvas();    }    FUNGRID.drawGameObjects();    FUNGRID.updateTimer();}FUNGRID.addGameObject = function (go) {    FUNGRID.gameObjects.push(go);    if (go.polyLine) {        FUNGRID.polyLineGameObjects.push(go);    }    if (go.zone) {        FUNGRID.zoneGameObjects.push(go);    }    return go;}FUNGRID.moveViewport = function (x, y) {    FUNGRID.viewport.x = x;    FUNGRID.viewport.y = y;    FUNGRID.setFutureViewport(x, y);}FUNGRID.updateViewport = function () {    var dx = FUNGRID.futureViewport.x - FUNGRID.viewport.x;    var dy = FUNGRID.futureViewport.y - FUNGRID.viewport.y;    var r = Math.sqrt(dx * dx + dy * dy);    if (r < 0.5) {        FUNGRID.moveViewport(FUNGRID.futureViewport.x, FUNGRID.futureViewport.y);    } else {        // r = viewportDelay*(r >> 1)*deltaTime;        r = r * 0.4;        /* if (r > maxScrollSpeed*deltaTime) {         r = maxScrollSpeed*deltaTime;         } */        var v = Math.atan2(dy, dx);        FUNGRID.viewport.x += r * Math.cos(v);        FUNGRID.viewport.y += r * Math.sin(v);    }    if (FUNGRID.minVpX !== null) {        FUNGRID.viewport.x = Math.max(FUNGRID.viewport.x, FUNGRID.minVpX)    }    if (FUNGRID.maxVpX !== null) {        FUNGRID.viewport.x = Math.min(FUNGRID.viewport.x, FUNGRID.maxVpX)    }    if (FUNGRID.minVpY !== null) {        FUNGRID.viewport.y = Math.max(FUNGRID.viewport.y, FUNGRID.minVpY)    }    if (FUNGRID.maxVpY !== null) {        FUNGRID.viewport.y = Math.min(FUNGRID.viewport.y, FUNGRID.maxVpY)    }}FUNGRID.setFutureViewport = function (x, y) {    if (FUNGRID.minVpX !== null) {        x = Math.max(x, FUNGRID.minVpX)    }    if (FUNGRID.maxVpX !== null) {        x = Math.min(x, FUNGRID.maxVpX)    }    if (FUNGRID.minVpY !== null) {        y = Math.max(y, FUNGRID.minVpY)    }    if (FUNGRID.maxVpY !== null) {        y = Math.min(y, FUNGRID.maxVpY)    }    FUNGRID.futureViewport.x = x;    FUNGRID.futureViewport.y = y;}FUNGRID.updateTimer = function () {    FUNGRID.currentTime = new Date().getTime();    FUNGRID.deltaTime = FUNGRID.currentTime - FUNGRID.lastUpdate;    // TEMP: UngÃ¥r hopp i bevegelser etter zoom etc.    if (FUNGRID.deltaTime > 3 * FUNGRID.timeInterval) {        FUNGRID.deltaTime = FUNGRID.timeInterval;    }    FUNGRID.fps = (1000 / FUNGRID.deltaTime);    FUNGRID.lastUpdate = FUNGRID.currentTime;}FUNGRID.clearCanvas = function () {    FUNGRID.context.clearRect(0, 0, FUNGRID.w, FUNGRID.h);}FUNGRID.updateGameObjects = function () {    var deleteObject = -1;    var l = FUNGRID.gameObjects.length;    var ll;    var ii;    for (var i = 0; i < l; i++) {        if (FUNGRID.gameObjects[i]) {            if (!FUNGRID.gameObjects[i].update()) {                if (FUNGRID.gameObjects[i].polyLine) {                    ll = FUNGRID.polyLineGameObjects.length;                    for (ii = 0; ii < ll; ii++) {                        if (FUNGRID.gameObjects[i] === FUNGRID.polyLineGameObjects[ii]) {                            FUNGRID.polyLineGameObjects.splice(ii, 1);                            ii = ll;                        }                    }                }                if (FUNGRID.gameObjects[i].zone) {                    ll = FUNGRID.zoneGameObjects.length;                    for (ii = 0; ii < ll; ii++) {                        if (FUNGRID.gameObjects[i] === FUNGRID.zoneGameObjects[ii]) {                            FUNGRID.zoneGameObjects.splice(ii, 1);                            ii = ll;                        }                    }                }                FUNGRID.gameObjects[i].destroy();                FUNGRID.gameObjects[i] = null;                FUNGRID.gameObjects.splice(i, 1);                i--;                l--;            }        }    }}FUNGRID.destroy = function() {	var l = FUNGRID.gameObjects.length;    for (var i = 0; i < l; i++) {    	FUNGRID.gameObjects[i].destroy();        FUNGRID.gameObjects[i] = null;    }    FUNGRID.gameObjects = [];}FUNGRID.drawGameObjects = function () {    for (var i = 0; i < FUNGRID.gameObjects.length; i++) {        FUNGRID.gameObjects[i].drawGameObject();        if (( FUNGRID.gameObjects[i].polyLine && FUNGRID.gameObjects[i].polyLineVisible) || ( FUNGRID.gameObjects[i].zone && FUNGRID.gameObjects[i].zoneVisible)) {            FUNGRID.gameObjects[i].drawPolyLines();        }    }    if (FUNGRID.drawFPS) {        FUNGRID.context.fillText(Math.round(FUNGRID.fps), 1, 9);    }}FUNGRID.RepeatSettings = function (repeatEveryX, repeatEveryY, noRepeatBeforeX, noRepeatBeforeY, noRepeatAfterX, noRepeatAfterY) {    // optional parameters default values:    repeatEveryX = repeatEveryX || null;    repeatEveryY = repeatEveryY || null;    noRepeatBeforeX = noRepeatBeforeX || null;    noRepeatBeforeY = noRepeatBeforeY || null;    noRepeatAfterX = noRepeatAfterX || null;    noRepeatAfterY = noRepeatAfterY || null;    // create repeat settings:    var rs = {};    rs.repeatEveryX = repeatEveryX;    rs.noRepeatBeforeX = noRepeatBeforeX;    rs.noRepeatAfterX = noRepeatAfterX;    rs.repeatEveryY = repeatEveryY;    rs.noRepeatBeforeY = noRepeatBeforeY;    rs.noRepeatAfterY = noRepeatAfterY;    return rs;}FUNGRID.polyLineCollision = function (from, to, checkOutsideViewport) {    var closestCollision;    var l = FUNGRID.polyLineGameObjects.length;    var col;    for (var i = 0; i < l; i++) {        col = FUNGRID.polyLineGameObjects[i].collision(from, to, checkOutsideViewport);        if (col) {            if (closestCollision) {                if ((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y) < (closestCollision.point.x - from.x) * (closestCollision.point.x - from.x) + (closestCollision.point.y - from.y) * (closestCollision.point.y - from.y)) {                    closestCollision = col;                }            } else {                closestCollision = col;            }        }    }    return closestCollision;}FUNGRID.zonesContainsPoint = function (p, type) {    type = type || "";    var zones = [];    var l = FUNGRID.zoneGameObjects.length;    for (var i = 0; i < l; i++) {        if (FUNGRID.zoneGameObjects[i].containsPoint(p, type)) {            zones.push(FUNGRID.zoneGameObjects[i]);        }    }    return zones;}FUNGRID.addPolyLineToGameObject = function (go, pl) {    go.polyLine = pl;    go.polyLineVisible = false;    go.polyLineLeft = null;    go.polyLineRight = null;    go.collision = function (from, to, checkOutsideViewport) {        checkOutsideViewport = checkOutsideViewport || false;        var p;        var fromPoint = FUNGRID.Point(from.x - this.posX, from.y - this.posY);        var toPoint = FUNGRID.Point(to.x - this.posX, to.y - this.posY);        if (checkOutsideViewport || this.inViewport()) {            p = this.polyLine.collisionPoint(fromPoint, toPoint);            if (p) {                // FUNGRID.log("go.collision "+p.toString());                return {point: FUNGRID.Point(p.x + this.posX, p.y + this.posY), parameter: this.polyLine.lastCollisionPointParameter, polyLineGameObject: this};            }        }        return null;    };    go.pointFromParameter = function (parameter, returnPointsOutsidePolyLine) {        returnPointsOutsidePolyLine = returnPointsOutsidePolyLine || false;        var p = this.polyLine.pointFromParameter(parameter, returnPointsOutsidePolyLine);        if (p) {            return FUNGRID.Point(p.x + this.posX, p.y + this.posY);        }        return null;    };    return go;}FUNGRID.connectPolyLineGameObjects = function (gos) {	for (var i = 0; i<gos.length-1; i++) {		gos[i].polyLineRight = gos[i+1];		gos[i+1].polyLineLeft = gos[i];	}}FUNGRID.addZoneToGameObject = function (go, pl, zoneType) {    zoneType = zoneType || "";    go.zone = pl;    go.zoneVisible = false;    go.zoneType = zoneType;    go.zoneEnabled = true;    go.containsPoint = function (p, type) {        if (!this.zoneEnabled) {            return false;        }        if (type === "" || type === this.zoneType) {            if (this.zone.containsPoint(FUNGRID.Point(p.x - this.posX, p.y - this.posY))) {                return true;            }        }    };}FUNGRID.addPhysicsToGameObject = function (go) {    go.physics = true;    go.moveable = true;}// Returns GameObjectFUNGRID.GameObject = function (idName, image, initPosX, initPosY, scrollFactorX, scrollFactorY, repeatSettings, moveable, initSpeedX, initSpeedY, initAccelerationX, initAccelerationY, minSpeedX, maxSpeedX, minSpeedY, maxSpeedY, initRotation, initScaleX, initScaleY) {    // optional parameters default values:    image = image || null;    initPosX = initPosX || 0;    initPosY = initPosY || 0;    scrollFactorX = scrollFactorX || 1;    scrollFactorY = scrollFactorY || 1;    repeatSettings = repeatSettings || null;    moveable = moveable || false;    initSpeedX = initSpeedX || 0;    initSpeedY = initSpeedY || 0;    initAccelerationX = initAccelerationX || 0;    initAccelerationY = initAccelerationY || 0;    minSpeedX = minSpeedX || null;    maxSpeedX = maxSpeedX || null;    minSpeedY = minSpeedY || null;    maxSpeedY = maxSpeedY || null;    initRotation = initRotation || 0;    initScaleX = initScaleX || 1;    initScaleY = initScaleY || 1;    // create game object:    var go = {};    // game object properties:    go.idName = idName;    go.image = image;    go.posX = initPosX;    go.posY = initPosY;    go.canvasPosX = initPosX;    go.canvasPosY = initPosY;    go.scrollFactorX = scrollFactorX;    go.scrollFactorY = scrollFactorY;    go.repeatSettings = repeatSettings;    go.moveable = moveable;    go.speedX = initSpeedX;    go.speedY = initSpeedY;    go.accelerationX = initAccelerationX;    go.accelerationY = initAccelerationY;    go.minSpeedX = minSpeedX;    go.maxSpeedX = maxSpeedX;    go.minSpeedY = minSpeedY;    go.maxSpeedY = maxSpeedY;    go.rotation = initRotation;    go.scaleX = initScaleX;    go.scaleY = initScaleY;    go.destroyMe = false;    go.visible = true;    go.zone = null;    go.polyLine = null;    go.physics = false;    go.polyLineGameObject = null;    go.parameter = 0;    go.parameterSpeed = 0;    go.lifetime = 0;    go.dieAfterLifetime = null;    go.dieOutsideViewport = null;    go.dieOutsideRectangle = null;    // game object default functions    go.update = function () {        go.lifetime += FUNGRID.deltaTime;        if (this.destroyMe) {            return false;        }        this.customEarlyUpdate();        if (this.moveable) {            this.updateSpeed();            if (this.physics) {                this.updatePhysics();            } else {                this.updateGridPosition();            }        }        this.customBeforeUpdateCanvasPosition();        this.updateCanvasPosition();        this.customAfterUpdateCanvasPosition();        if (this.repeatSettings != null) {            this.updateRepetition();        }        this.customLateUpdate();        return this.updateDies();    };    go.updateDies = function() {        if (this.dieAfterLifetime) {            if (this.lifetime >= this.dieAfterLifetime)  {                this.destroyMe = true;                return false;            }        }        if (this.dieOutsideViewport) {           if (!this.inViewport()) {               this.destroyMe = true;               return false;           }        }        if (this.dieOutsideRectangle) {            if (!this.dieOutsideViewport.containsPoint(FUNGRID.Point(this.posX,this.posY))) {                this.destroyMe = true;                return false;            }        }       return true;    }    go.destroy = function () {        FUNGRID.log("Destroyed!");    }    // custom updates    go.customEarlyUpdate = function () {    };    go.customBeforeUpdateCanvasPosition = function () {    };    go.customAfterUpdateCanvasPosition = function () {    };    go.customLateUpdate = function () {    };     go.customOnRepeat = function () {    };    go.customEnterPolyLineGameObject = function (){    };    // Update speed    go.updateSpeed = function () {        this.speedX += this.accelerationX * FUNGRID.deltaTime;        this.speedY += this.accelerationY * FUNGRID.deltaTime;        if (this.maxSpeedX != null) {            this.speedX = Math.min(this.speedX, this.maxSpeedX);        }        if (this.minSpeedX != null) {            this.speedX = Math.max(this.speedX, this.minSpeedX);        }        if (this.maxSpeedY != null) {            this.speedY = Math.min(this.speedY, this.maxSpeedY);        }        if (this.minSpeedY != null) {            this.speedY = Math.max(this.speedY, this.minSpeedY);        }    };    go.addSprite = function (idName, sx, sy, swidth, sheight, soffsetx, soffsety, imageDrawWidth, imageDrawHeight, rotationOffsetX, rotationOffsetY) {        idName = idName || "idle";        sx = sx || 0;        sy = sy || 0;        if (image) {            swidth = swidth || this.image.width;            sheight = sheight || this.image.height;        } else {            swidth = swidth || 0;            sheight = sheight || 0;        }        soffsetx = soffsetx || 0;        soffsety = soffsety || 0;        imageDrawWidth = imageDrawWidth || swidth;        imageDrawHeight = imageDrawHeight || sheight;        rotationOffsetX = rotationOffsetX || soffsetx;        rotationOffsetY = rotationOffsetY || soffsety;        var maxDrawingRadius = Math.max(imageDrawWidth + rotationOffsetX, imageDrawHeight + rotationOffsetY);        if (!this.sprites || (this.sprites.length == 1 && this.sprites[0].autosprite)) {            this.sprites = [];            this.spriteIndex = 0;        }        this.sprites.push({idName: idName, sx: sx, sy: sy, swidth: swidth, sheight: sheight, soffsetx: soffsetx, soffsety: soffsety, imageDrawWidth: imageDrawWidth, imageDrawHeight: imageDrawHeight, rotationOffsetX: rotationOffsetX, rotationOffsetY: rotationOffsetY, maxDrawingRadius: maxDrawingRadius});    };    // Draw polyLine or zone on the canvas    go.drawPolyLines = function () {        if (this.polyLine) {            FUNGRID.context.beginPath();            FUNGRID.context.moveTo(this.polyLine.points[0].x + this.canvasPosX, this.polyLine.points[0].y + this.canvasPosY);            for (var i = 1; i < this.polyLine.length; i++) {                FUNGRID.context.lineTo(this.polyLine.points[i].x + this.canvasPosX, this.polyLine.points[i].y + this.canvasPosY);            }            FUNGRID.context.stroke();        }        if (this.zone) {            FUNGRID.context.beginPath();            FUNGRID.context.moveTo(this.zone.points[0].x + this.canvasPosX, this.zone.points[0].y + this.canvasPosY);            for (var i = 1; i < this.zone.length; i++) {                FUNGRID.context.lineTo(this.zone.points[i].x + this.canvasPosX, this.zone.points[i].y + this.canvasPosY);            }            FUNGRID.context.stroke();        }    };    // Draw GameObject on the canvas using FUNGRID.context    go.drawGameObject = function () {        if (!this.visible || !this.image || !this.inViewport()) {            return;        }        if (this.rotation !== 0) {// Rotated drawing            FUNGRID.context.save();            FUNGRID.context.translate(this.canvasPosX, this.canvasPosY);            FUNGRID.context.rotate(this.rotation * Math.PI / 180);            if (this.sprites) {                // Sprite drawing                FUNGRID.context.drawImage(this.image, this.sprites[this.spriteIndex].sx, this.sprites[this.spriteIndex].sy, this.sprites[this.spriteIndex].swidth, this.sprites[this.spriteIndex].sheight, this.sprites[this.spriteIndex].rotationOffsetX * this.scaleX, this.sprites[this.spriteIndex].rotationOffsetY * this.scaleY, this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX, this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY);            } else {                // Simple drawing                FUNGRID.context.drawImage(this.image, 0, 0);            }            FUNGRID.context.restore();        } else {// Unrotated drawing            var x = Math.round(this.canvasPosX + this.sprites[this.spriteIndex].soffsetx * this.scaleX);            var y = Math.round(this.canvasPosY + this.sprites[this.spriteIndex].soffsety * this.scaleY);            var w = this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX;            var h = this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY;            FUNGRID.context.drawImage(this.image, this.sprites[this.spriteIndex].sx, this.sprites[this.spriteIndex].sy, this.sprites[this.spriteIndex].swidth, this.sprites[this.spriteIndex].sheight, x, y, w, h);        }    }    // Returns true if GameObject is inside the viewport (and should be rendered)    go.inViewport = function () {        if (this.rotation !== 0) {            // Rotated...            if (this.canvasPosX - this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleX > FUNGRID.vpW) {                return false;            }            if (this.canvasPosX + this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleX < 0) {                return false;            }            if (this.canvasPosY - this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleY > FUNGRID.vpH) {                return false;            }            if (this.canvasPosY + this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleY < 0) {                return false;            }        } else {            // Not rotated            var x = this.canvasPosX + this.sprites[this.spriteIndex].soffsetx * this.scaleX;            if (x > FUNGRID.vpW) {                return false;            }            var w = this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX;            if (x + w < 0) {                return false;            }            var y = this.canvasPosY + this.sprites[this.spriteIndex].soffsety * this.scaleY;            if (y > FUNGRID.vpH) {                return false;            }            var h = this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY;            if (y + h < 0) {                return false;            }        }        // In viewport! (at least almost)        return true;    }    // Update the position on the grid based on speed    go.updateGridPosition = function () {        this.posX += this.speedX * FUNGRID.deltaTime;        this.posY += this.speedY * FUNGRID.deltaTime;    }    go.updatePhysics = function () {        if (this.polyLineGameObject) {            // If attached to a PolyLine GameObject...            this.parameter += this.parameterSpeed * FUNGRID.deltaTime;            var p = this.polyLineGameObject.pointFromParameter(this.parameter);            if (p) {                this.posX = p.x;                this.posY = p.y;            } else {                if (this.parameter < 0 && this.polyLineGameObject.polyLineLeft) {                    while (this.parameter < 0) {                        if (this.polyLineGameObject.polyLineLeft) {                            if (this.jumpCheckLeft()) {                                this.leavePolyLineGameObject();                                break;                            } else {                                this.polyLineGameObject = this.polyLineGameObject.polyLineLeft;                                this.parameter += this.polyLineGameObject.polyLine.totalLength;                                p = this.polyLineGameObject.pointFromParameter(this.parameter);                                if (p) {                                    this.posX = p.x;                                    this.posY = p.y;                                }                            }                        } else {                            this.leavePolyLineGameObject();                        }                    }                } else if (this.parameter > this.polyLineGameObject.polyLine.totalLength && this.polyLineGameObject.polyLineRight) {                    while (this.parameter > this.polyLineGameObject.polyLine.totalLength) {                        if (this.polyLineGameObject.polyLineRight) {                            if (this.jumpCheckRight()) {                                this.leavePolyLineGameObject();                                break;                            } else {                                this.parameter -= this.polyLineGameObject.polyLine.totalLength;                                this.polyLineGameObject = this.polyLineGameObject.polyLineRight;                                p = this.polyLineGameObject.pointFromParameter(this.parameter);                                if (p) {                                    this.posX = p.x;                                    this.posY = p.y;                                }                            }                        } else {                            this.leavePolyLineGameObject();                        }                    }                } else {                    this.leavePolyLineGameObject();                }            }        } else {            // If not attached to a PolyLine Game Object ...            var c = FUNGRID.polyLineCollision(FUNGRID.Point(this.posX, this.posY), FUNGRID.Point(this.posX + this.speedX * FUNGRID.deltaTime, this.posY + this.speedY * FUNGRID.deltaTime));            if (c && this.speedY > 0) {                // Collision with a PolyLine GameObject                this.polyLineGameObject = c.polyLineGameObject;                this.parameter = c.parameter;                this.posX = c.point.x;                this.posY = c.point.y;                this.customEnterPolyLineGameObject();                // FUNGRID.log("kollisjon " + c.point.toString());            } else {                // No collision                this.updateGridPosition();            }        }    }    go.leavePolyLineGameObject = function () {        var p = this.polyLineGameObject.pointFromParameter(this.parameter, true);        // FUNGRID.log("p:" + p.toString() + " " + this.posX + "," + this.posY);        this.speedX = (p.x - this.posX) / FUNGRID.deltaTime;        this.speedY = (p.y - this.posY) / FUNGRID.deltaTime;        this.polyLineGameObject = null;        this.updateGridPosition();    }    go.jumpCheckLeft = function () {        return false;    }    go.jumpCheckRight = function () {        return false;    }    // Returns true if (x,y) is inside the current sprite bounding box    go.inside = function (x, y) {        x += this.sprites[this.spriteIndex].soffsetx * this.scaleX;        if (x >= this.posX && x <= this.posX + this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX) {            y += this.sprites[this.spriteIndex].soffsety * this.scaleY;            if (y >= this.posY && y <= this.posY + this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY) {                return true;            }        }        return false;    }    go.updateCanvasPosition = function () {        if (this.scrollFactorX !== 0) {            this.canvasPosX = this.scrollFactorX * (this.posX - FUNGRID.viewport.x);            this.canvasPosY = this.scrollFactorY * (this.posY - FUNGRID.viewport.y);        } else {            this.canvasPosX = this.posX;            if (this.scrollFactorY !== 0) {                this.canvasPosY = this.scrollFactorY * (this.posY - FUNGRID.viewport.y);            } else {                this.canvasPosY = this.posY;            }        }    }    go.updateRepetition = function () {        if (this.repeatSettings.repeatEveryX != null) {            if (this.canvasPosX + this.image.width < 0) {                this.posX += this.repeatSettings.repeatEveryX;                if (this.repeatSettings.noRepeatAfterX != null) {                    if (this.posX > this.repeatSettings.noRepeatAfterX) {                        this.posX -= this.repeatSettings.repeatEveryX;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            } else if (this.canvasPosX > this.repeatSettings.repeatEveryX - this.image.width) {                this.posX -= this.repeatSettings.repeatEveryX;                if (this.repeatSettings.noRepeatBeforeX != null) {                    if (this.posX < this.repeatSettings.noRepeatBeforeX) {                        this.posX += this.repeatSettings.repeatEveryX;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            }        }        if (this.repeatSettings.repeatEveryY != null) {            if (this.canvasPosY + this.image.height < 0) {                this.posY += this.repeatSettings.repeatEveryY;                if (this.repeatSettings.noRepeatAfterY) {                    if (this.posY > this.repeatSettings.noRepeatAfterY) {                        this.posY -= this.repeatSettings.repeatEveryY;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            } else if (this.canvasPosY > this.repeatSettings.repeatEveryY - this.image.height) {                this.posY -= this.repeatSettings.repeatEveryY;                if (this.repeatSettings.noRepeatBeforeY != null) {                    if (this.posY < this.repeatSettings.noRepeatBeforeY) {                        this.posY += this.repeatSettings.repeatEveryY;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            }        }    }    go.addSprite();    go.sprites[0].autosprite = true;    // return new game object    return go;}// Returns PolyLine object// Line of 2 or more points (1 or more line segments).// Commonly used to define platforms (open PolyLine) or zones (closed PolyLine) .// Positions are relative to the game object.// The first point is recommended to be the left-most point when creating platforms.FUNGRID.PolyLine = function (points) {    points = points || [];    // create polyline object    var pl = {};    pl.points = points;    pl.lastCollisionPointParameter;    pl.init = function () {        this.lengths = [];        this.length = this.points.length;        this.derivatives = [];        this.totalLength = 0;        this.closed = false;        var minX;        var minY;        var maxX;        var maxY;        for (var i = 0; i < this.length; i++) {            if (i < this.length - 1) {                var l = Math.sqrt((this.points[i + 1].x - this.points[i].x) * (this.points[i + 1].x - this.points[i].x) + (this.points[i + 1].y - this.points[i].y) * (this.points[i + 1].y - this.points[i].y));                this.lengths.push(l);                this.derivatives.push((this.points[i + 1].y - this.points[i].y) / (this.points[i + 1].x - this.points[i].x));                this.totalLength += l;            }            if (i === 0) {                minX = maxX = this.points[i].x;                minY = maxY = this.points[i].y;            } else {                if (this.points[i].x < minX) {                    minX = this.points[i].x;                } else if (this.points[i].x > maxX) {                    maxX = this.points[i].x;                }                if (this.points[i].y < minY) {                    minY = this.points[i].y;                } else if (this.points[i].y > maxY) {                    maxY = this.points[i].y;                }            }        }        this.boundRect = FUNGRID.Rectangle(minX, minY, maxX - minX, maxY - minY);        if (points[0].x == this.points[this.length - 1].x && this.points[0].y == this.points[this.length - 1].y) {            this.closed = true;        }    }    pl.init();    // Returns true if a Point p is inside a closed PolyLine object    pl.containsPoint = function (p) {        if (!this.closed || !this.boundRect.containsPoint(p)) {            return false;        }        var inside = false;        var xold = this.points[this.length - 1].x;        var yold = this.points[this.length - 1].y;        var x1;        var y1;        var x2;        var y2;        var xnew;        var ynew;        for (var i = 0; i < this.length; i++) {            xnew = this.points[i].x;            ynew = this.points[i].y;            if (xnew > xold) {                x1 = xold;                x2 = xnew;                y1 = yold;                y2 = ynew;            } else {                x1 = xnew;                x2 = xold;                y1 = ynew;                y2 = yold;            }            if ((xnew < p.x) == (p.x <= xold) && ((p.y - y1) * (x2 - x1) < (y2 - y1) * (p.x - x1))) {                inside = !inside;            }            xold = xnew;            yold = ynew;        }        return inside;    }    // Returns true if Rectangle rect intersects boundRect of the PolyLine object    pl.intersectsBoundRect = function (rect) {        return this.boundRect.intersects(rect);    }    // Returns an intersection Point between two line segments if the point is within both line segments    // First line segment from Point line1a to Point line1b, second from Point line2a to Point line2B    pl.intersectionPoint = function (line1a, line1b, line2a, line2b) {        // FUNGRID.log(line1a.toString() + "-" + line1b.toString() + " x " + line2a.x+","+line2a.y + " - " + line2b.x+","+line2b.y);        // Formula based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/        var nemnar = (line2b.y - line2a.y) * (line1b.x - line1a.x) - (line2b.x - line2a.x) * (line1b.y - line1a.y);        if (nemnar !== 0) {            var ua_teljar = (line2b.x - line2a.x) * (line1a.y - line2a.y) - (line2b.y - line2a.y) * (line1a.x - line2a.x);            var ub_teljar = (line1b.x - line1a.x) * (line1a.y - line2a.y) - (line1b.y - line1a.y) * (line1a.x - line2a.x);            var ua = ua_teljar / nemnar;            var ub = ub_teljar / nemnar;            // Check if we are inside both line segments:            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {                return FUNGRID.Point(line1a.x + ua * (line1b.x - line1a.x), line1a.y + ua * (line1b.y - line1a.y));            }        }        return null;    }    // Returns closest collision Point between line segment and the PolyLine object or null if there are no collision    pl.collisionPoint = function (from, to) {        var closestPoint = null;        var parameter = 0;        var ip;        for (var i = 0; i < this.length - 1; i++) {            ip = this.intersectionPoint(from, to, this.points[i], this.points[i + 1]);            if (ip) {                if (closestPoint) {                    if (Math.sqrt((ip.x - from.x) * (ip.x - from.x) + (ip.y - from.y) * (ip.y - from.y)) < Math.sqrt((closestPoint.x - from.x) * (closestPoint.x - from.x) + (closestPoint.y - from.y) * (closestPoint.y - from.y))) {                        closestPoint = ip;                        this.lastCollisionPointParameter = parameter + Math.sqrt((ip.x - this.points[i].x) * (ip.x - this.points[i].x) + (ip.y - this.points[i].y) * (ip.y - this.points[i].y));                    }                } else {                    closestPoint = ip;                    this.lastCollisionPointParameter = parameter + Math.sqrt((ip.x - this.points[i].x) * (ip.x - this.points[i].x) + (ip.y - this.points[i].y) * (ip.y - this.points[i].y));                }            }            parameter += this.lengths[i];        }        return closestPoint;    }    // Returns the derivative for a point on the Polyline defined by a parameter value    // The parameter defines a point on the PolyLine by the distance along the line from the first point on the PolyLine    pl.derivativeFromParameter = function (parameter) {        for (var i = 0; i < this.length; i++) {            if (parameter > this.lengths[i]) {                parameter -= this.lengths[i];            } else {                return derivatives[i];            }        }        if (parameter < 0) {            return derivatives[0];        }        return derivatives[derivatives.length - 1];    }    // Returns a point on the PolyLine defined by a parameter value or null if the parameter is outside the PolyLine (unless returnPointsOutsidePolyLine is true)    // The parameter defines a point on the PolyLine by the distance along the line from the first point on the PolyLine    pl.pointFromParameter = function (parameter, returnPointsOutsidePolyLine) {        returnPointsOutsidePolyLine = returnPointsOutsidePolyLine || false;        if (returnPointsOutsidePolyLine) {            if (parameter < 0) {                var a = Math.atan(this.derivatives[0]);                return FUNGRID.Point(parameter * Math.cos(a) + this.points[0].x, parameter * Math.sin(a) + this.points[0].y);                // AS3: return Point.polar(parameter,Math.atan(derivatives[0])).add(points[0]);            } else if (parameter > this.totalLength) {                parameter -= this.totalLength;                var a = Math.atan(this.derivatives[this.derivatives.length - 1]);                return FUNGRID.Point(parameter * Math.cos(a) + this.points[this.length - 1].x, parameter * Math.sin(a) + this.points[this.length - 1].y);                // AS3: return Point.polar(parameter,Math.atan(derivatives[derivatives.length-1])).add(points[this.length-1]);            }        }        if (this.closed) {            // Move parameter to a point within the totalLength if the polyline is closed.            while (parameter < 0) {                parameter += this.totalLength;            }            while (parameter > this.totalLength) {                parameter -= this.totalLength;            }        } else if (parameter < 0 || parameter > this.totalLength) {            return null;        }        for (var i = 0; i < this.length; i++) {            if (parameter > this.lengths[i]) {                parameter -= this.lengths[i];            } else {                return FUNGRID.Point(this.points[i].x + parameter * (this.points[i + 1].x - this.points[i].x) / this.lengths[i], this.points[i].y + parameter * (this.points[i + 1].y - this.points[i].y) / this.lengths[i]);            }        }        return null;    }    // If not already closed, make the polyLine closed by adding a Point withe same coordinates as the first point.    pl.close = function () {        if (!this.closed) {            this.points.push(FUNGRID.Point(this.points[0].x, this.points[0].y));            this.init();        }    }    return pl;}// Returns canvas with tinted image. Everything is tinted except for transparent pixelsFUNGRID.simpleTint = function (image,r,g,b) {    var canvas = document.createElement('canvas');    canvas.width  = image.width;    canvas.height = image.height;    var context = canvas.getContext("2d");    context.drawImage(image, 0, 0);    var imageData = context.getImageData(0,0,canvas.width, canvas.height);    var pos = 0;    for (var i = 0; i<imageData.data.length; i+=4) {        if (imageData.data[i+3]>0) {            imageData.data[i] = Math.max(0,Math.min(255, r));            imageData.data[i+1] = Math.max(0,Math.min(255, g));            imageData.data[i+2] = Math.max(0,Math.min(255, b));        }    }    context.putImageData(imageData,0,0);    return canvas;}