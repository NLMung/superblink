// JavaScript DocumentFUNGRID = (function() {    log('FunGrid.js v0.962');    var scale;    var canvas; // canvas DOM object    var context; // canvas context    var gameObjects = [];    var polyLineGameObjects = [];    var zoneGameObjects = [];    var canX = 0;    var canY = 0;    var isDown = 0;    var w = 0;    var h = 0;    var wpx = 0;    var hpx = 0;    // Viewport    var viewport;    var futureViewport;    var minVpX = null;    var maxVpX = null;    var minVpY = null;    var maxVpY = null;    var maxScrollSpeed = 2000;    var viewportDelay = 1.5;    var doClearCanvas = false;    function log(message) {        try {            console.log(message);        } catch (exception) {            return;        }    }// Returns Rectangle objectfunction Rectangle(x, y, width, height) {    x = x || 0;    y = y || 0;    width = width || 0;    height = height || 0;    var r = {x: x, y: y, width: width, height: height};    // Returns true if the Rectangle object contains Point p    r.containsPoint = function (p) {        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;    }    // Returns true if the Rectangle object intersects Rectangle rect    r.intersects = function (rect) {        return rect.x < this.x + this.width && rect.x + rect.width > this.x && rect.y < this.y + this.height && rect.y + rect.height > this.y;    }    return r;}function width() {    return w;}function height() {    return h;}// Returns Point objectfunction Point(x, y) {    x = x || 0;    y = y || 0;    p = {x: x, y: y};    p.toString = function () {        return "{x:" + x + ", y:" + y + "}";    }    return p;}function init(canvasIdString,scaleNumber) {    scale = scaleNumber || 1;    canvasId = canvasIdString || "canvas";    canvas = document.getElementById(canvasId);    w = canvas.width/scale;    h = canvas.height/scale;    wpx = canvas.width;    hpx = canvas.height;    viewport = Rectangle(0, 0, w, h);    futureViewport = Point(0,0);    context = canvas.getContext("2d");    gameObjects = [];    polyLineGameObjects = [];    zoneGameObjects = [];    if (!canvas || !context) {        log("FunGrid init failed!");        return;    }    log("FunGrid initialized! Scale: "+scale);}function update(view) {    view = view || "";    updateViewport();    updateGameObjects(view);    if (doClearCanvas) {    	clearCanvas();    }    drawGameObjects(view);}function setClearCanvas(clear) {    doClearCanvas = clear;}function addGameObject(go, view) {    view = view || "";    go.view = view;    gameObjects.push(go);    if (go.polyLine) {        polyLineGameObjects.push(go);    }    if (go.zone) {        zoneGameObjects.push(go);    }    return go;}function getContext() {    return context;}function moveViewport(x, y) {   viewport.x = x;   viewport.y = y;   setFutureViewport(x, y);}function vpX() {    return viewport.x;}function vpY() {    return viewport.y;}function viewportSettings(minX,maxX,minY,maxY) {    minVpX = minX;    maxVpX = maxX;    minVpY = minY;    maxVpY = maxY;}function updateViewport() {    var dx = futureViewport.x - viewport.x;    var dy = futureViewport.y - viewport.y;    var r = Math.sqrt(dx * dx + dy * dy);    if (r < 0.5) {        moveViewport(futureViewport.x, futureViewport.y);    } else {        r = r * 0.05;        var v = Math.atan2(dy, dx);     viewport.x += r * Math.cos(v);     viewport.y += r * Math.sin(v);    }    if (minVpX !== null) {        viewport.x = Math.max(viewport.x, minVpX);    }    if (maxVpX !== null) {        viewport.x = Math.min(viewport.x, maxVpX);    }    if (minVpY !== null) {        viewport.y = Math.max(viewport.y, minVpY);    }    if (maxVpY !== null) {        viewport.y = Math.min(viewport.y, maxVpY);    }}function setFutureViewport(x, y) {    if (minVpX !== null) {        x = Math.max(x, minVpX)    }    if (maxVpX !== null) {        x = Math.min(x, maxVpX)    }    if (minVpY !== null) {        y = Math.max(y, minVpY)    }    if (maxVpY !== null) {        y = Math.min(y, maxVpY)    }    futureViewport.x = x;    futureViewport.y = y;}function clearCanvas() {   context.clearRect(0, 0, wpx, hpx);}function updateGameObjects(view) {    var deleteObject = -1;    var l = gameObjects.length;    var ll;    var ii;    for (var i = 0; i < l; i++) {        if (gameObjects[i]) {            if (gameObjects[i].view===view) {                if (!gameObjects[i].update()) {                    if (gameObjects[i].polyLine) {                        ll = polyLineGameObjects.length;                        for (ii = 0; ii < ll; ii++) {                            if (gameObjects[i] === polyLineGameObjects[ii]) {                                polyLineGameObjects.splice(ii, 1);                                ii = ll;                            }                        }                    }                    if (gameObjects[i].zone) {                        ll = zoneGameObjects.length;                        for (ii = 0; ii < ll; ii++) {                            if (gameObjects[i] === zoneGameObjects[ii]) {                                zoneGameObjects.splice(ii, 1);                                ii = ll;                            }                        }                    }                    gameObjects[i].destroy();                    gameObjects[i] = null;                    gameObjects.splice(i, 1);                    i--;                    l--;                }            }        }    }}function destroyView(view) {    view = view || "";    var l = gameObjects.length;    for (var i = 0; i < l; i++) {        if (gameObjects[i].view===view) {            gameObjects[i].destroy();        }    }}function destroy() {	var l = gameObjects.length;    for (var i = 0; i < l; i++) {    	gameObjects[i].destroy();    }    gameObjects = [];}function drawGameObjects(view) {    var l = gameObjects.length;    for (var i = 0; i < l; i++) {        gameObjects[i].drawSprite(view);        if ((gameObjects[i].polyLine && gameObjects[i].polyLineVisible) || (gameObjects[i].zone && gameObjects[i].zoneVisible)) {            gameObjects[i].drawPolyLines();        }    }}function RepeatSettings(repeatEveryX, repeatEveryY, noRepeatBeforeX, noRepeatBeforeY, noRepeatAfterX, noRepeatAfterY) {    // optional parameters default values:    repeatEveryX = repeatEveryX || null;    repeatEveryY = repeatEveryY || null;    noRepeatBeforeX = noRepeatBeforeX || null;    noRepeatBeforeY = noRepeatBeforeY || null;    noRepeatAfterX = noRepeatAfterX || null;    noRepeatAfterY = noRepeatAfterY || null;    // create repeat settings:    var rs = {};    rs.repeatEveryX = repeatEveryX;    rs.noRepeatBeforeX = noRepeatBeforeX;    rs.noRepeatAfterX = noRepeatAfterX;    rs.repeatEveryY = repeatEveryY;    rs.noRepeatBeforeY = noRepeatBeforeY;    rs.noRepeatAfterY = noRepeatAfterY;    return rs;}function polyLineCollision(from, to, checkOutsideViewport) {    var closestCollision;    var l = polyLineGameObjects.length;    var col;    for (var i = 0; i < l; i++) {        col = polyLineGameObjects[i].collision(from, to, checkOutsideViewport);        if (col) {            if (closestCollision) {                if ((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y) < (closestCollision.point.x - from.x) * (closestCollision.point.x - from.x) + (closestCollision.point.y - from.y) * (closestCollision.point.y - from.y)) {                    closestCollision = col;                }            } else {                closestCollision = col;            }        }    }    return closestCollision;}function zonesContainsPoint(p, type) {    type = type || "";    var zones = [];    var l = zoneGameObjects.length;    for (var i = 0; i < l; i++) {        if (zoneGameObjects[i].containsPoint(p, type)) {            zones.push(zoneGameObjects[i]);        }    }    return zones;}function addPolyLineToGameObject(go, pl) {    go.polyLine = pl;    go.polyLineVisible = false;    go.polyLineLeft = null;    go.polyLineRight = null;    go.collision = function (from, to, checkOutsideViewport) {        checkOutsideViewport = checkOutsideViewport || false;        var p;        var fromPoint = Point(from.x - this.posX, from.y - this.posY);        var toPoint = Point(to.x - this.posX, to.y - this.posY);        if (checkOutsideViewport || this.inViewport()) {            p = this.polyLine.collisionPoint(fromPoint, toPoint);            if (p) {                return {point: Point(p.x + this.posX, p.y + this.posY), parameter: this.polyLine.lastCollisionPointParameter, polyLineGameObject: this};            }        }        return null;    };    go.pointFromParameter = function (parameter, returnPointsOutsidePolyLine) {        returnPointsOutsidePolyLine = returnPointsOutsidePolyLine || false;        var p = this.polyLine.pointFromParameter(parameter, returnPointsOutsidePolyLine);        if (p) {            return Point(p.x + this.posX, p.y + this.posY);        }        return null;    };    return go;}function connectPolyLineGameObjects(gos) {	for (var i = 0; i<gos.length-1; i++) {		gos[i].polyLineRight = gos[i+1];		gos[i+1].polyLineLeft = gos[i];	}}function addZoneToGameObject(go, pl, zoneType) {    zoneType = zoneType || "";    go.zone = pl;    go.zoneVisible = false;    go.zoneType = zoneType;    go.zoneEnabled = true;    go.containsPoint = function (p, type) {        if (!this.zoneEnabled) {            return false;        }        if (type === "" || type === this.zoneType) {            if (this.zone.containsPoint(Point(p.x - this.posX, p.y - this.posY))) {                return true;            }        }    };}function addPhysicsToGameObject(go) {    go.physics = true;    go.moveable = true;}// Returns GameObjectfunction GameObject(idName, image, initPosX, initPosY, scrollFactorX, scrollFactorY, repeatSettings, moveable, initSpeedX, initSpeedY, initAccelerationX, initAccelerationY, minSpeedX, maxSpeedX, minSpeedY, maxSpeedY, initRotation, initScaleX, initScaleY) {    // optional parameters default values:    image = image || null;    if (!image) log(idName+" GameObject(...) WARNING: image = null");    initPosX = initPosX || 0;    initPosY = initPosY || 0;    if (scrollFactorX===undefined) scrollFactorX = 1;    if (scrollFactorY===undefined) scrollFactorY = 1;    // scrollFactorX = scrollFactorX || 1;    // scrollFactorY = scrollFactorY || 1;    repeatSettings = repeatSettings || null;    moveable = moveable || false;    initSpeedX = initSpeedX || 0;    initSpeedY = initSpeedY || 0;    initAccelerationX = initAccelerationX || 0;    initAccelerationY = initAccelerationY || 0;    minSpeedX = minSpeedX || null;    maxSpeedX = maxSpeedX || null;    minSpeedY = minSpeedY || null;    maxSpeedY = maxSpeedY || null;    initRotation = initRotation || 0;    initScaleX = initScaleX || 1;    initScaleY = initScaleY || 1;    // create game object:    var go = {};    // game object properties:    go.idName = idName;    go.image = image;    go.posX = initPosX;    go.posY = initPosY;    go.canvasPosX = initPosX;    go.canvasPosY = initPosY;    go.scrollFactorX = scrollFactorX;    go.scrollFactorY = scrollFactorY;    go.repeatSettings = repeatSettings;    go.moveable = moveable;    go.speedX = initSpeedX;    go.speedY = initSpeedY;    go.accelerationX = initAccelerationX;    go.accelerationY = initAccelerationY;    go.minSpeedX = minSpeedX;    go.maxSpeedX = maxSpeedX;    go.minSpeedY = minSpeedY;    go.maxSpeedY = maxSpeedY;    go.rotation = initRotation;    go.scaleX = initScaleX;    go.scaleY = initScaleY;    go.destroyMe = false;    go.visible = true;    go.zone = null;    go.polyLine = null;    go.view = "";    go.physics = false;    go.physicsOutsideViewport = false;    go.polyLineGameObject = null;    go.parameter = 0;    go.parameterSpeed = 0;    go.updates = 0;    go.dieAfterUpdates = null;    go.dieOutsideViewport = null;    go.dieOutsideRectangle = null;    // game object default functions    go.toString = function () {        return this.idName+" "+this.posX+","+this.posY+" "+this.canvasPosX+","+this.canvasPosY;    };    go.update = function () {        go.updates += 1;        if (this.destroyMe) {            return false;        }        this.customEarlyUpdate();        if (this.moveable) {            this.updateSpeed();            if (this.physics) {                this.updatePhysics();            } else {                this.updateGridPosition();            }        }        this.customBeforeUpdateCanvasPosition();        this.updateCanvasPosition();        this.customAfterUpdateCanvasPosition();        if (this.repeatSettings != null) {            this.updateRepetition();        }        this.customLateUpdate();        return this.updateDies();    };    go.updateDies = function() {        if (this.dieAfterUpdates) {            if (this.updates >= this.dieAfterUpdates)  {                this.destroyMe = true;                return false;            }        }        if (this.dieOutsideViewport) {           if (!this.inViewport()) {               this.destroyMe = true;               return false;           }       }       if (this.dieOutsideRectangle) {        if (!this.dieOutsideViewport.containsPoint(Point(this.posX,this.posY))) {            this.destroyMe = true;            return false;        }    }    return true;}go.destroy = function () {    this.destroyMe = true;    log(this.idName+ " destroyed!");}    // custom updates    go.customEarlyUpdate = function () {    };    go.customBeforeUpdateCanvasPosition = function () {    };    go.customAfterUpdateCanvasPosition = function () {    };    go.customLateUpdate = function () {    };    go.customOnRepeat = function () {    };    go.customEnterPolyLineGameObject = function (){    };    // Update speed    go.updateSpeed = function () {        this.speedX += this.accelerationX;        this.speedY += this.accelerationY;        if (this.maxSpeedX != null) {            this.speedX = Math.min(this.speedX, this.maxSpeedX);        }        if (this.minSpeedX != null) {            this.speedX = Math.max(this.speedX, this.minSpeedX);        }        if (this.maxSpeedY != null) {            this.speedY = Math.min(this.speedY, this.maxSpeedY);        }        if (this.minSpeedY != null) {            this.speedY = Math.max(this.speedY, this.minSpeedY);        }    };    go.addSprite = function (idName, sx, sy, swidth, sheight, soffsetx, soffsety, imageDrawWidth, imageDrawHeight, rotationOffsetX, rotationOffsetY) {        if (swidth+sx>this.image.width) {            FUNGRID.log("Warning! "+this.idName+" Sprite "+idName+" is exceeding the image (too wide). Will not draw.");        }        if (sheight+sy>this.image.height) {            FUNGRID.log("Warning! "+this.idName+" Sprite "+idName+" is exceeding the image (too high). Will not draw.");        }        idName = idName || "idle";        sx = sx || 0;        sy = sy || 0;        if (this.image) {            swidth = swidth || this.image.width;            sheight = sheight || this.image.height;        } else {            swidth = swidth || 0;            sheight = sheight || 0;        }        soffsetx = soffsetx || 0;        soffsety = soffsety || 0;        imageDrawWidth = imageDrawWidth || swidth;        imageDrawHeight = imageDrawHeight || sheight;        rotationOffsetX = rotationOffsetX || soffsetx;        rotationOffsetY = rotationOffsetY || soffsety;        var maxDrawingRadius = Math.max(imageDrawWidth + rotationOffsetX, imageDrawHeight + rotationOffsetY);        if (!this.sprites || (this.sprites.length == 1 && this.sprites[0].autosprite)) {            this.sprites = [];            this.spriteIndex = 0;        }        this.sprites.push({idName: idName, sx: sx, sy: sy, swidth: swidth, sheight: sheight, soffsetx: soffsetx, soffsety: soffsety, imageDrawWidth: imageDrawWidth, imageDrawHeight: imageDrawHeight, rotationOffsetX: rotationOffsetX, rotationOffsetY: rotationOffsetY, maxDrawingRadius: maxDrawingRadius});    };    go.setSprite = function (idName) {        l = this.sprites.length;        for (var i = 0; i<l; i++) {            if (this.sprites.idNAme===idName) {                this.spriteIndex = i;                return;            }        }        FUNGRID.log("Sprite "+idName+" not found on GameObject "+this.idName);    }    // Draw polyLine or zone on the canvas    go.drawPolyLines = function () {        if (this.polyLine) {            context.beginPath();            context.moveTo((this.polyLine.points[0].x + this.canvasPosX)*scale, (this.polyLine.points[0].y + this.canvasPosY)*scale);            var l = this.polyLine.length;            for (var i = 1; i < l; i++) {                context.lineTo((this.polyLine.points[i].x + this.canvasPosX)*scale, (this.polyLine.points[i].y + this.canvasPosY)*scale);            }            context.stroke();        }        if (this.zone) {            context.beginPath();            context.moveTo((this.zone.points[0].x + this.canvasPosX)*scale, (this.zone.points[0].y + this.canvasPosY)*scale);            var l = this.zone.length;            for (var i = 1; i < l; i++) {                context.lineTo((this.zone.points[i].x + this.canvasPosX)*scale, (this.zone.points[i].y + this.canvasPosY)*scale);            }            context.stroke();        }    };        // Draw GameObject on the canvas using FUNGRID.context    go.drawSprite = function (view) {        if (!this.visible || !this.image ||  !this.inViewport()  ||  (this.view!==view && this.view!=='')) {            return;        }        if (this.spriteDD === undefined) {            this.lastSpriteIndex = -1;            this.spriteDD = {};        }        if (true ||Â this.lastSpriteIndex !== this.spriteIndex) {            this.spriteDD.sx = this.sprites[this.spriteIndex].sx * scale;            this.spriteDD.sy = this.sprites[this.spriteIndex].sy * scale;            this.spriteDD.swidth = this.sprites[this.spriteIndex].swidth * scale;            this.spriteDD.sheight = this.sprites[this.spriteIndex].sheight * scale;            this.spriteDD.w = this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX*scale;            this.spriteDD.h = this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY*scale;            this.lastSpriteIndex = this.spriteIndex;        }        this.spriteDD.x = Math.round(this.canvasPosX + this.sprites[this.spriteIndex].soffsetx * this.scaleX)*scale;        this.spriteDD.y = Math.round(this.canvasPosY + this.sprites[this.spriteIndex].soffsety * this.scaleY)*scale;      //  log(this.spriteDD.sx+","+this.spriteDD.sy+" "+this.spriteDD.swidth+"x"+this.spriteDD.sheight+" "+this.spriteDD.x+","+this.spriteDD.y+" "+this.spriteDD.w+"x"+this.spriteDD.h);                        if (this.rotation !== 0) {            // Rotated drawing            var roffx = this.sprites[this.spriteIndex].rotationOffsetX * this.scaleX * scale;            var roffy = this.sprites[this.spriteIndex].rotationOffsetY * this.scaleY * scale;              var r = this.rotation * Math.PI / 180;            var tx = this.spriteDD.x-roffx;            var ty = this.spriteDD.y-roffy;            context.translate(tx, ty);            context.rotate(r);            context.drawImage(this.image, this.spriteDD.sx, this.spriteDD.sy, this.spriteDD.swidth, this.spriteDD.sheight, roffx, roffy, this.spriteDD.w, this.spriteDD.h);            context.rotate(-r);            context.translate(-tx, -ty);        } else {if (this.spriteDD.x<0) {            this.spriteDD.sx -= this.spriteDD.x/this.scaleX;            this.spriteDD.swidth += this.spriteDD.x/this.scaleX;            this.spriteDD.w += this.spriteDD.x;            this.spriteDD.x = 0;        }        var xoverflow = this.spriteDD.x+this.spriteDD.w-wpx;        if (xoverflow>0) {            this.spriteDD.swidth -= xoverflow/this.scaleX;            this.spriteDD.w -= xoverflow;        }        if (this.spriteDD.swidth<1) {            return;        }        if (this.spriteDD.y<0) {            this.spriteDD.sy -= this.spriteDD.y/this.scaleY;            this.spriteDD.sheight += this.spriteDD.y/this.scaleY;            this.spriteDD.h += this.spriteDD.y;            this.spriteDD.y = 0;        }        var yoverflow = this.spriteDD.y+this.spriteDD.h-hpx;        if (yoverflow>0) {            this.spriteDD.sheight -= yoverflow/this.scaleY;            this.spriteDD.h -= yoverflow;        }        if (this.spriteDD.sheight<1) {            return;        }                        this.drawSprite2();        }    }    go.drawSprite2 = function () {        // log(this.spriteDD.sx+","+this.spriteDD.sy+" "+this.spriteDD.swidth+"x"+this.spriteDD.sheight+" "+this.spriteDD.x+","+this.spriteDD.y+" "+this.spriteDD.w+"x"+this.spriteDD.h);        context.drawImage(this.image, this.spriteDD.sx, this.spriteDD.sy, this.spriteDD.swidth, this.spriteDD.sheight, this.spriteDD.x, this.spriteDD.y, this.spriteDD.w, this.spriteDD.h);    }    // Returns true if GameObject is inside the viewport (and should be rendered)    go.inViewport = function () {        if (this.rotation !== 0) {            // Rotated...            if (this.canvasPosX - this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleX > w) {                return false;            }            if (this.canvasPosX + this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleX < 0) {                return false;            }            if (this.canvasPosY - this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleY > h) {                return false;            }            if (this.canvasPosY + this.sprites[this.spriteIndex].maxDrawingRadius * this.scaleY < 0) {                return false;            }        } else {            // Not rotated            var x = this.canvasPosX + this.sprites[this.spriteIndex].soffsetx * this.scaleX;            if (x > w) {                return false;            }            var w = this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX;            if (x + w < 0) {                return false;            }            var y = this.canvasPosY + this.sprites[this.spriteIndex].soffsety * this.scaleY;            if (y > h) {                return false;            }            var h = this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY;            if (y + h < 0) {                return false;            }        }        // In viewport! (at least almost)        return true;    }    // Update the position on the grid based on speed    go.updateGridPosition = function () {        this.posX += this.speedX;        this.posY += this.speedY;    }    go.updatePhysics = function () {        if (this.polyLineGameObject) {            // If attached to a PolyLine GameObject...            this.parameter += this.parameterSpeed;            var p = this.polyLineGameObject.pointFromParameter(this.parameter);            if (p) {                this.posX = p.x;                this.posY = p.y;            } else {                if (this.parameter < 0 && this.polyLineGameObject.polyLineLeft) {                    while (this.parameter < 0) {                        if (this.polyLineGameObject.polyLineLeft) {                            if (this.jumpCheckLeft()) {                                this.leavePolyLineGameObject();                                break;                            } else {                                this.polyLineGameObject = this.polyLineGameObject.polyLineLeft;                                this.parameter += this.polyLineGameObject.polyLine.totalLength;                                p = this.polyLineGameObject.pointFromParameter(this.parameter);                                if (p) {                                    this.posX = p.x;                                    this.posY = p.y;                                }                            }                        } else {                            this.leavePolyLineGameObject();                        }                    }                } else if (this.parameter > this.polyLineGameObject.polyLine.totalLength && this.polyLineGameObject.polyLineRight) {                    while (this.parameter > this.polyLineGameObject.polyLine.totalLength) {                        if (this.polyLineGameObject.polyLineRight) {                            if (this.jumpCheckRight()) {                                this.leavePolyLineGameObject();                                break;                            } else {                                this.parameter -= this.polyLineGameObject.polyLine.totalLength;                                this.polyLineGameObject = this.polyLineGameObject.polyLineRight;                                p = this.polyLineGameObject.pointFromParameter(this.parameter);                                if (p) {                                    this.posX = p.x;                                    this.posY = p.y;                                }                            }                        } else {                            this.leavePolyLineGameObject();                        }                    }                } else {                    this.leavePolyLineGameObject();                }            }        } else {            // If not attached to a PolyLine Game Object ...            var c = polyLineCollision(Point(this.posX, this.posY), Point(this.posX + this.speedX, this.posY + this.speedY), this.physicsOutsideViewport);            if (c && this.speedY > 0) {                // Collision with a PolyLine GameObject                this.polyLineGameObject = c.polyLineGameObject;                this.parameter = c.parameter;                this.posX = c.point.x;                this.posY = c.point.y;                this.customEnterPolyLineGameObject();                // FUNGRID.log("kollisjon " + c.point.toString());            } else {                // No collision                this.updateGridPosition();            }        }    }    go.leavePolyLineGameObject = function () {        var p = this.polyLineGameObject.pointFromParameter(this.parameter, true);        // FUNGRID.log("p:" + p.toString() + " " + this.posX + "," + this.posY);        this.speedX = p.x - this.posX;        this.speedY = p.y - this.posY        this.polyLineGameObject = null;        this.updateGridPosition();    }    go.jumpCheckLeft = function () {        return false;    }    go.jumpCheckRight = function () {        return false;    }    // Returns true if (x,y) is inside the current sprite bounding box    go.inside = function (x, y) {        x += this.sprites[this.spriteIndex].soffsetx * this.scaleX;       //  if (x >= this.posX && x <= this.posX + this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX) {        if (x >= this.canvasPosX && x <= this.canvasPosX + this.sprites[this.spriteIndex].imageDrawWidth * this.scaleX) {            y += this.sprites[this.spriteIndex].soffsety * this.scaleY;            // if (y >= this.posY && y <= this.posY + this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY) {            if (y >= this.canvasPosY && y <= this.canvasPosY + this.sprites[this.spriteIndex].imageDrawHeight * this.scaleY) {                return true;            }        }        return false;    }    go.updateCanvasPosition = function () {        if (this.scrollFactorX !== 0) {            this.canvasPosX = this.scrollFactorX * (this.posX - getViewport().x);            this.canvasPosY = this.scrollFactorY * (this.posY - getViewport().y);        } else {            this.canvasPosX = this.posX;            if (this.scrollFactorY !== 0) {                this.canvasPosY = this.scrollFactorY * (this.posY - getViewport().y);            } else {                this.canvasPosY = this.posY;            }        }    }    go.updateRepetition = function () {        if (this.repeatSettings.repeatEveryX != null) {            if (this.canvasPosX + this.sprites[this.spriteIndex].soffsetx + this.sprites[this.spriteIndex].imageDrawWidth < 0) {                this.posX += this.repeatSettings.repeatEveryX/this.scrollFactorX;                if (this.repeatSettings.noRepeatAfterX != null) {                    if (this.posX > this.repeatSettings.noRepeatAfterX/this.scrollFactorX) {                        this.posX -= this.repeatSettings.repeatEveryX/this.scrollFactorX;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            } else if (this.canvasPosX > this.repeatSettings.repeatEveryX - this.sprites[this.spriteIndex].soffsetx - this.sprites[this.spriteIndex].imageDrawWidth) {                this.posX -= this.repeatSettings.repeatEveryX/this.scrollFactorX;                if (this.repeatSettings.noRepeatBeforeX != null) {                    if (this.posX < this.repeatSettings.noRepeatBeforeX/this.scrollFactorX) {                        this.posX += this.repeatSettings.repeatEveryX/this.scrollFactorX;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            }        }        if (this.repeatSettings.repeatEveryY != null) {            if (this.canvasPosY + this.sprites[this.spriteIndex].soffsety + this.sprites[this.spriteIndex].imageDrawHeight < 0) {                this.posY += this.repeatSettings.repeatEveryY/this.scrollFactorY;                if (this.repeatSettings.noRepeatAfterY) {                    if (this.posY > this.repeatSettings.noRepeatAfterY/this.scrollFactorY) {                        this.posY -= this.repeatSettings.repeatEveryY/this.scrollFactorY;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            } else if (this.canvasPosY > this.repeatSettings.repeatEveryY - this.sprites[this.spriteIndex].soffsety - this.sprites[this.spriteIndex].imageDrawHeight) {                this.posY -= this.repeatSettings.repeatEveryY/this.scrollFactorY;                if (this.repeatSettings.noRepeatBeforeY != null) {                    if (this.posY < this.repeatSettings.noRepeatBeforeY/this.scrollFactorY) {                        this.posY += this.repeatSettings.repeatEveryY/this.scrollFactorY;                    }                }                this.customOnRepeat();                this.updateCanvasPosition();            }        }    }    go.addSprite();    go.sprites[0].autosprite = true;    // return new game object    return go;}// Returns PolyLine object// Line of 2 or more points (1 or more line segments).// Commonly used to define platforms (open PolyLine) or zones (closed PolyLine) .// Positions are relative to the game object.// The first point is recommended to be the left-most point when creating platforms.function PolyLine(points) {    points = points || [];    // create polyline object    var pl = {};    pl.points = points;    pl.lastCollisionPointParameter;    pl.init = function () {        this.lengths = [];        this.length = this.points.length;        this.derivatives = [];        this.totalLength = 0;        this.closed = false;        var minX;        var minY;        var maxX;        var maxY;        for (var i = 0; i < this.length; i++) {            if (i < this.length - 1) {                var l = Math.sqrt((this.points[i + 1].x - this.points[i].x) * (this.points[i + 1].x - this.points[i].x) + (this.points[i + 1].y - this.points[i].y) * (this.points[i + 1].y - this.points[i].y));                this.lengths.push(l);                this.derivatives.push((this.points[i + 1].y - this.points[i].y) / (this.points[i + 1].x - this.points[i].x));                this.totalLength += l;            }            if (i === 0) {                minX = maxX = this.points[i].x;                minY = maxY = this.points[i].y;            } else {                if (this.points[i].x < minX) {                    minX = this.points[i].x;                } else if (this.points[i].x > maxX) {                    maxX = this.points[i].x;                }                if (this.points[i].y < minY) {                    minY = this.points[i].y;                } else if (this.points[i].y > maxY) {                    maxY = this.points[i].y;                }            }        }        this.boundRect = FUNGRID.Rectangle(minX, minY, maxX - minX, maxY - minY);        if (points[0].x === this.points[this.length - 1].x && this.points[0].y === this.points[this.length - 1].y) {            this.closed = true;        }    }    pl.init();    // Returns true if a Point p is inside a closed PolyLine object    pl.containsPoint = function (p) {        if (!this.closed || !this.boundRect.containsPoint(p)) {            return false;        }        var inside = false;        var xold = this.points[this.length - 1].x;        var yold = this.points[this.length - 1].y;        var x1;        var y1;        var x2;        var y2;        var xnew;        var ynew;        var l = this.length;        for (var i = 0; i < l; i++) {            xnew = this.points[i].x;            ynew = this.points[i].y;            if (xnew > xold) {                x1 = xold;                x2 = xnew;                y1 = yold;                y2 = ynew;            } else {                x1 = xnew;                x2 = xold;                y1 = ynew;                y2 = yold;            }            if ((xnew < p.x) == (p.x <= xold) && ((p.y - y1) * (x2 - x1) < (y2 - y1) * (p.x - x1))) {                inside = !inside;            }            xold = xnew;            yold = ynew;        }        return inside;    }    // Returns true if Rectangle rect intersects boundRect of the PolyLine object    pl.intersectsBoundRect = function (rect) {        return this.boundRect.intersects(rect);    }    // Returns an intersection Point between two line segments if the point is within both line segments    // First line segment from Point line1a to Point line1b, second from Point line2a to Point line2B    pl.intersectionPoint = function (line1a, line1b, line2a, line2b) {        // FUNGRID.log(line1a.toString() + "-" + line1b.toString() + " x " + line2a.x+","+line2a.y + " - " + line2b.x+","+line2b.y);        // Formula based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/        var nemnar = (line2b.y - line2a.y) * (line1b.x - line1a.x) - (line2b.x - line2a.x) * (line1b.y - line1a.y);        if (nemnar !== 0) {            var ua_teljar = (line2b.x - line2a.x) * (line1a.y - line2a.y) - (line2b.y - line2a.y) * (line1a.x - line2a.x);            var ub_teljar = (line1b.x - line1a.x) * (line1a.y - line2a.y) - (line1b.y - line1a.y) * (line1a.x - line2a.x);            var ua = ua_teljar / nemnar;            var ub = ub_teljar / nemnar;            // Check if we are inside both line segments:            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {                return Point(line1a.x + ua * (line1b.x - line1a.x), line1a.y + ua * (line1b.y - line1a.y));            }        }        return null;    }    // Returns closest collision Point between line segment and the PolyLine object or null if there are no collision    pl.collisionPoint = function (from, to) {        var closestPoint = null;        var parameter = 0;        var ip;        var l = this.length - 1;        for (var i = 0; i < l; i++) {            ip = this.intersectionPoint(from, to, this.points[i], this.points[i + 1]);            if (ip) {                if (closestPoint) {                    if (Math.sqrt((ip.x - from.x) * (ip.x - from.x) + (ip.y - from.y) * (ip.y - from.y)) < Math.sqrt((closestPoint.x - from.x) * (closestPoint.x - from.x) + (closestPoint.y - from.y) * (closestPoint.y - from.y))) {                        closestPoint = ip;                        this.lastCollisionPointParameter = parameter + Math.sqrt((ip.x - this.points[i].x) * (ip.x - this.points[i].x) + (ip.y - this.points[i].y) * (ip.y - this.points[i].y));                    }                } else {                    closestPoint = ip;                    this.lastCollisionPointParameter = parameter + Math.sqrt((ip.x - this.points[i].x) * (ip.x - this.points[i].x) + (ip.y - this.points[i].y) * (ip.y - this.points[i].y));                }            }            parameter += this.lengths[i];        }        return closestPoint;    }    // Returns the derivative for a point on the Polyline defined by a parameter value    // The parameter defines a point on the PolyLine by the distance along the line from the first point on the PolyLine    pl.derivativeFromParameter = function (parameter) {        var l = this.length;        for (var i = 0; i < l; i++) {            if (parameter > this.lengths[i]) {                parameter -= this.lengths[i];            } else {                return derivatives[i];            }        }        if (parameter < 0) {            return derivatives[0];        }        return derivatives[derivatives.length - 1];    }    // Returns a point on the PolyLine defined by a parameter value or null if the parameter is outside the PolyLine (unless returnPointsOutsidePolyLine is true)    // The parameter defines a point on the PolyLine by the distance along the line from the first point on the PolyLine    pl.pointFromParameter = function (parameter, returnPointsOutsidePolyLine) {        returnPointsOutsidePolyLine = returnPointsOutsidePolyLine || false;        if (returnPointsOutsidePolyLine) {            if (parameter < 0) {                var a = Math.atan(this.derivatives[0]);                return Point(parameter * Math.cos(a) + this.points[0].x, parameter * Math.sin(a) + this.points[0].y);                // AS3: return Point.polar(parameter,Math.atan(derivatives[0])).add(points[0]);            } else if (parameter > this.totalLength) {                parameter -= this.totalLength;                var a = Math.atan(this.derivatives[this.derivatives.length - 1]);                return Point(parameter * Math.cos(a) + this.points[this.length - 1].x, parameter * Math.sin(a) + this.points[this.length - 1].y);                // AS3: return Point.polar(parameter,Math.atan(derivatives[derivatives.length-1])).add(points[this.length-1]);            }        }        if (this.closed) {            // Move parameter to a point within the totalLength if the polyline is closed.            while (parameter < 0) {                parameter += this.totalLength;            }            while (parameter > this.totalLength) {                parameter -= this.totalLength;            }        } else if (parameter < 0 || parameter > this.totalLength) {            return null;        }        var l = this.length;        for (var i = 0; i < l; i++) {            if (parameter > this.lengths[i]) {                parameter -= this.lengths[i];            } else {                return Point(this.points[i].x + parameter * (this.points[i + 1].x - this.points[i].x) / this.lengths[i], this.points[i].y + parameter * (this.points[i + 1].y - this.points[i].y) / this.lengths[i]);            }        }        return null;    }    // If not already closed, make the polyLine closed by adding a Point withe same coordinates as the first point.    pl.close = function () {        if (!this.closed) {            this.points.push(Point(this.points[0].x, this.points[0].y));            this.init();        }    }    return pl;}// Returns canvas with tinted image. Everything is tinted except for transparent pixelsfunction simpleTint(image,r,g,b) {    var canvas = document.createElement('canvas');    canvas.width  = image.width;    canvas.height = image.height;    var context = canvas.getContext("2d");    context.drawImage(image, 0, 0);    var imageData = context.getImageData(0,0,canvas.width, canvas.height);    var pos = 0;    var l = imageData.data.length;    for (var i = 0; i<l; i+=4) {        if (imageData.data[i+3]>0) {            imageData.data[i] = Math.max(0,Math.min(255, r));            imageData.data[i+1] = Math.max(0,Math.min(255, g));            imageData.data[i+2] = Math.max(0,Math.min(255, b));        }    }    context.putImageData(imageData,0,0);    return canvas;}function toDataURL() {    return canvas.toDataURL('image/png');}function getViewport() {    return viewport;}return {    log:log,    Rectangle:Rectangle,    Point:Point,    init:init,    update:update,    addGameObject:addGameObject,    moveViewport:moveViewport,    updateViewport:updateViewport,    setFutureViewport:setFutureViewport,    futureViewport:futureViewport,    clearCanvas:clearCanvas,    updateGameObjects:updateGameObjects,    destroy:destroy,    destroyView:destroyView,    drawGameObjects:drawGameObjects,    RepeatSettings:RepeatSettings,    polyLineCollision:polyLineCollision,    zonesContainsPoint:zonesContainsPoint,    addPolyLineToGameObject:addPolyLineToGameObject,    connectPolyLineGameObjects:connectPolyLineGameObjects,    addZoneToGameObject:addZoneToGameObject,    addPhysicsToGameObject:addPhysicsToGameObject,    GameObject:GameObject,    PolyLine:PolyLine,    simpleTint:simpleTint,    setClearCanvas:setClearCanvas,    getContext:getContext,    toDataURL:toDataURL,    getViewport:getViewport,    width:width,    height:height,    viewportSettings:viewportSettings,    vpX:vpX,    vpY:vpY};})();